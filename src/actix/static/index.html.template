<!DOCTYPE html>
<!--
/*!******************************************************************************
 * UniChat
 * Copyright (C) 2025-2026 Voguh <voguhofc@protonmail.com>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 ******************************************************************************/
-->
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>Widget | Voguh's UniChat</title>

        <base href="{{WIDGET_BASE_URL}}">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css" />
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" />
        <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>

        <style>
            {{WIDGET_STYLE}}
        </style>
        <script defer>
            document.addEventListener("DOMContentLoaded", () => {
                function connect() {
                    let wsSchema = window.location.protocol === "https:" ? "wss" : "ws";
                    let wsHost = window.location.host;
                    const socket = new WebSocket(`${wsSchema}://${wsHost}/ws`)

                    socket.addEventListener("open", () => {
                        console.log("Socket connected");
                    });

                    socket.addEventListener("message", (message) => {
                        const event = JSON.parse(message.data);

                        if (event.type === "unichat:connected") {
                            window.dispatchEvent(new CustomEvent("unichat:connected", { detail: event.data }));
                        } else if (event.type === "unichat:history") {
                            for (const cachedEvent of event.data) {
                                window.dispatchEvent(new CustomEvent("unichat:event", { detail: cachedEvent }));
                            }
                        } else if (event.type === "unichat:userstore_update") {
                            window.dispatchEvent(new CustomEvent("unichat:userstore_update", { detail: event.data }));
                        } else if (event.type != null && event.data != null) {
                            window.dispatchEvent(new CustomEvent("unichat:event", { detail: event }));
                        }
                    });

                    socket.addEventListener("close", () => {
                        console.log("Socket disconnected. Attempting to reconnect in 1 second...");
                        setTimeout(connect, 1000);
                    });

                    socket.addEventListener("error", (err) => {
                        console.error("Socket encountered error: ", err.message, "Closing socket");
                        socket.close();
                    });

                    function jsonrpcSendCommand(method, params) {
                        return new Promise((resolve, reject) => {
                            const id = crypto.randomUUID();
                            const body = { jsonrpc: "2.0", id, method, params }

                            socket.send(JSON.stringify(body));

                            function handleResponse(message) {
                                const event = JSON.parse(message.data);

                                if (event.jsonrpc === "2.0" && event.id === id) {
                                    socket.removeEventListener("message", handleResponse);

                                    if (event.error) {
                                        const error = new Error(event.error.message || "Unknown JSON-RPC error");
                                        error.code = event.error.code;
                                        error.data = event.error.data;
                                        reject(error);
                                    } else {
                                        resolve(event.result);
                                    }
                                }
                            }

                            socket.addEventListener("message", handleResponse);
                            setTimeout(() => {
                                socket.removeEventListener("message", handleResponse);
                                const error = new Error("Timeout waiting for userstore get response");
                                error.code = -1;
                                reject(error);
                            }, 5000);
                        });
                    }

                    globalThis.UniChatAPI = {
                        getUserstoreItem: async function(key) {
                            return jsonrpcSendCommand("userstore:get", [key]);
                        }
                    }
                }

                connect();

                window.addEventListener("message", ({ data: event }) => {
                    if (event.type === "unichat:event") {
                        window.dispatchEvent(new CustomEvent("unichat:event", { detail: event.detail }));
                    }
                });
            });
        </script>
        <script defer>
            document.addEventListener("DOMContentLoaded", () => {
                {{WIDGET_SCRIPT}}
            });
        </script>
    </head>
    <body>
        {{WIDGET_HTML}}
    </body>
</html>
